import React, { useEffect, useRef, useState } from 'react'
import { SHAPES, COLORS } from './TetrominoConstants'
import { rotate, randomTetromino } from './TetrominoLogic'

const COLS = 10
const ROWS = 20
const CELL = 24

type Piece = { key:string, shape:number[][], x:number, y:number }

function makeEmptyGrid(){
  return Array.from({length:ROWS}, ()=>Array(COLS).fill(0))
}

function collide(grid:any[][], piece:Piece){
  const {shape,x,y} = piece
  for(let r=0;r<shape.length;r++){
    for(let c=0;c<shape[r].length;c++){
      if(shape[r][c]){
        const gx = x + c
        const gy = y + r
        if(gx<0 || gx>=COLS || gy>=ROWS) return true
        if(gy>=0 && grid[gy][gx]) return true
      }
    }
  }
  return false
}

function lockPieceToGrid(grid:any[][], piece:Piece){
  const newGrid = grid.map(r=>r.slice())
  for(let r=0;r<piece.shape.length;r++){
    for(let c=0;c<piece.shape[r].length;c++){
      if(piece.shape[r][c]){
        const gx = piece.x + c
        const gy = piece.y + r
        if(gy>=0 && gy<ROWS && gx>=0 && gx<COLS) newGrid[gy][gx] = (COLORS as any)[piece.key]
      }
    }
  }
  return newGrid
}

function clearLines(grid:any[][]){
  // garbage rows are stored as 'G:#000' but should be treated as filled for clears
  const newGrid = grid.map(r=>r.slice())
  let cleared = 0
  function isFilled(cell:any){ return !!cell }
  for(let r=ROWS-1;r>=0;r--){
    if(newGrid[r].every((cell:any)=> isFilled(cell))){ newGrid.splice(r,1); newGrid.unshift(Array(COLS).fill(0)); cleared++; r++ }
  }
  return {grid:newGrid, cleared}
}

function tryRotate(grid:any[][], piece:Piece){
  const rotated = {...piece, shape: rotate(piece.shape)}
  if(!collide(grid,rotated)) return rotated
  const shifts = [-1,1,-2,2]
  for(const s of shifts){
    const moved = {...rotated, x: rotated.x + s}
    if(!collide(grid,moved)) return moved
  }
  return piece
}

function createQueue(n=6){
  const q:Piece[] = []
  for(let i=0;i<n;i++){ const p = randomTetromino(); q.push({...p, x:3, y:-2}) }
  return q
}
function createStart(){ const p = randomTetromino(); return {...p, x:3, y:-2} }

export default function GameBoard(){
  const canvas1 = useRef<HTMLCanvasElement|null>(null)
  const canvas2 = useRef<HTMLCanvasElement|null>(null)

  const [grid1,setGrid1] = useState<any[][]>(makeEmptyGrid())
  const [grid2,setGrid2] = useState<any[][]>(makeEmptyGrid())
  const grid1Ref = useRef<any[][]>(grid1)
  const grid2Ref = useRef<any[][]>(grid2)
  useEffect(()=>{ grid1Ref.current = grid1 }, [grid1])
  useEffect(()=>{ grid2Ref.current = grid2 }, [grid2])

  const [queue1,setQueue1] = useState<Piece[]>(()=>createQueue())
  const [queue2,setQueue2] = useState<Piece[]>(()=>createQueue())

  const [piece1,setPiece1] = useState<Piece>(createStart())
  const [piece2,setPiece2] = useState<Piece>(createStart())

  // refs to keep latest piece/queue for synchronous input handling to avoid race conditions
  const piece1Ref = useRef<Piece>(piece1)
  const queue1Ref = useRef<Piece[]>(queue1)
  useEffect(()=>{ piece1Ref.current = piece1 }, [piece1])
  useEffect(()=>{ queue1Ref.current = queue1 }, [queue1])

  function setPiece1AndRef(p:Piece){ piece1Ref.current = p; setPiece1(p) }
  const piece2Ref = useRef<Piece>(piece2)
  const queue2Ref = useRef<Piece[]>(queue2)
  useEffect(()=>{ piece2Ref.current = piece2 }, [piece2])
  useEffect(()=>{ queue2Ref.current = queue2 }, [queue2])
  function setPiece2AndRef(p:Piece){ piece2Ref.current = p; setPiece2(p) }

  const [held1,setHeld1] = useState<Piece|null>(null)
  const [held2,setHeld2] = useState<Piece|null>(null)
  const [holdUsed1,setHoldUsed1] = useState(false)
  const [holdUsed2,setHoldUsed2] = useState(false)
  const held1Ref = useRef<Piece|null>(held1)
  const held2Ref = useRef<Piece|null>(held2)
  useEffect(()=>{ held1Ref.current = held1 }, [held1])
  useEffect(()=>{ held2Ref.current = held2 }, [held2])

  // soft drop, combos and back-to-back tracking
  const [softDrop1, setSoftDrop1] = useState(false)
  const combo1 = useRef(0)
  const combo2 = useRef(0)
  const b2b1 = useRef(false)
  const b2b2 = useRef(false)
  // input repeat/interval refs
  const horizontalInterval = useRef<number|undefined>(undefined)
  const horizontalDir = useRef<'left'|'right'|null>(null)
  const softInterval = useRef<number|undefined>(undefined)
  const pressedKeys = useRef<Record<string, boolean>>({})
  const startTime = useRef<number>(Date.now())

  const [score1,setScore1] = useState(0)
  const [score2,setScore2] = useState(0)

  const [running1,setRunning1] = useState(true)
  const [running2,setRunning2] = useState(true)
  const [gameOver,setGameOver] = useState(false)
  const [winner,setWinner] = useState<'player'|'opponent'|'draw'|null>(null)

  // draw
  function draw(canvas:HTMLCanvasElement|null, grid:any[][], active?:Piece){
    if(!canvas) return
    const ctx = canvas.getContext('2d')!
    canvas.width = COLS*CELL
    canvas.height = ROWS*CELL
    ctx.fillStyle = '#071226'
    ctx.fillRect(0,0,canvas.width,canvas.height)
    // draw background cells and ghost (silhouette) before active piece
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const v = grid[r][c]
        if(v){
          // draw garbage differently: stored as 'G:#000' where everything after 'G:' is the color
          if(typeof v === 'string' && v.startsWith('G:')) ctx.fillStyle = v.slice(2)
          else ctx.fillStyle = v as string
          ctx.fillRect(c*CELL, r*CELL, CELL-1, CELL-1)
        } else { ctx.strokeStyle = '#0b2233'; ctx.strokeRect(c*CELL, r*CELL, CELL, CELL) }
      }
    }
    if(active){
      // draw ghost / silhouette
      let ghost = {...active}
      while(!collide(grid, {...ghost, y: ghost.y+1})) ghost.y++
      ctx.save()
      ctx.globalAlpha = 0.35
      ctx.fillStyle = (COLORS as any)[active.key] || '#fff'
      for(let r=0;r<ghost.shape.length;r++){
        for(let c=0;c<ghost.shape[r].length;c++){
          if(ghost.shape[r][c]){
            const gx = ghost.x + c
            const gy = ghost.y + r
            if(gy>=0) ctx.fillRect(gx*CELL, gy*CELL, CELL-1, CELL-1)
          }
        }
      }
      ctx.restore()

      // draw active piece normally
      ctx.fillStyle = (COLORS as any)[active.key] || '#fff'
      for(let r=0;r<active.shape.length;r++){
        for(let c=0;c<active.shape[r].length;c++){
          if(active.shape[r][c]){
            const gx = active.x + c
            const gy = active.y + r
            if(gy>=0) ctx.fillRect(gx*CELL, gy*CELL, CELL-1, CELL-1)
          }
        }
      }
    }
  }

  useEffect(()=> draw(canvas1.current, grid1, piece1), [grid1, piece1])
  useEffect(()=> draw(canvas2.current, grid2, piece2), [grid2, piece2])

  // reason: 'soft'|'hard'|'gravity' - affects spawn timing
  function lockAndClear(player:number, p:Piece, reason:'soft'|'hard'|'gravity' = 'gravity'){
    // ensure we lock the currently active piece (avoid stale piece objects causing wrong locks)
    if(player===1) p = piece1Ref.current
    else p = piece2Ref.current
    // compute garbage using guideline rules (basic: single/double/triple/tetris, combos, back-to-back, all clear)
  function computeGarbageFor(player:number, cleared:number, newGrid:any[][]){
      // base by cleared lines
      let base = 0
      let qualifiesB2B = false
      if(cleared===4){ base = 4; qualifiesB2B = true }
      else if(cleared===3) base = 2
      else if(cleared===2) base = 1
      else if(cleared===1) base = 0

      // all clear detection
  const allClear = !newGrid.some((row:any[])=> row.some((cell:any)=>!!cell))
      if(allClear && cleared>0){ base += 7; qualifiesB2B = true }

      // combo bonus rules: (simple mapping from guideline)
      const comboRef = player===1 ? combo1 : combo2
      let comboExtra = 0
      if(comboRef.current>=2 && comboRef.current<=3) comboExtra = 1
      else if(comboRef.current===4 || comboRef.current===5) comboExtra = 2
      else if(comboRef.current>5) comboExtra = 2 + Math.floor((comboRef.current-4)/2)

      // back-to-back bonus
      const b2bRef = player===1 ? b2b1 : b2b2
      let b2bExtra = 0
      if(b2bRef.current && qualifiesB2B) b2bExtra = 1

      const total = base + comboExtra + b2bExtra
      const qualifies = qualifiesB2B
      return { total, qualifies, allClear }
    }

    if(player===1){
      setGrid1(g=>{
        const before = g.map(r=>r.slice())
        const ng = lockPieceToGrid(g,p)
        // find which rows will be cleared and which columns were filled by this piece
        const willClear: number[] = []
        for(let r=0;r<ROWS;r++){
          if(ng[r].every((cell:any)=>!!cell)) willClear.push(r)
        }
        const res = clearLines(ng)
        if(res.cleared) setScore1(s=>s + res.cleared*100)

        const info = computeGarbageFor(1, res.cleared, res.grid)
        // determine hole column based on columns in cleared rows that were filled by this piece
        let hole = Math.max(0, Math.min(COLS-1, p.x + Math.floor((p.shape[0]?.length||1)/2)))
        if(willClear.length>0){
          // examine the lowest cleared row and find columns where before was empty but ng had filled
          const row = willClear[willClear.length-1]
          const filledByPiece: number[] = []
          for(let c=0;c<COLS;c++){
            if(!before[row][c] && ng[row][c]) filledByPiece.push(c)
          }
          if(filledByPiece.length>0) hole = filledByPiece[Math.floor(filledByPiece.length/2)]
        }

        if(info.total) {
          // send garbage after specified frame delay handled inside receiveGarbage
          receiveGarbage(2, info.total, hole)
        }

        // update combo and b2b refs
        if(res.cleared>0) combo1.current = combo1.current + 1
        else combo1.current = 0
        b2b1.current = info.qualifies ? true : false

        // check for top-row occupation on this updated grid and end game immediately if needed
        if(res.grid[0].some((cell:any)=>!!cell)){
          setRunning1(false); setGameOver(true); setWinner('opponent')
        }
        if(grid2[0].some((cell:any)=>!!cell)){
          setRunning1(false); setRunning2(false); setGameOver(true); setWinner('player')
        }

        // spawn behavior: immediate for 'hard' and 'gravity', delayed 500ms for 'soft'
        if(!gameOver){
          if(reason==='soft'){
            setTimeout(()=>{ if(!gameOver) spawn(1) }, 500)
          } else {
            spawn(1)
          }
        }

        return res.grid
      })
    } else {
      setGrid2(g=>{
        const before = g.map(r=>r.slice())
        const ng = lockPieceToGrid(g,p)
        const willClear: number[] = []
        for(let r=0;r<ROWS;r++){
          if(ng[r].every((cell:any)=>!!cell)) willClear.push(r)
        }
        const res = clearLines(ng)
        if(res.cleared) setScore2(s=>s + res.cleared*100)

        const info = computeGarbageFor(2, res.cleared, res.grid)
        let hole = Math.max(0, Math.min(COLS-1, p.x + Math.floor((p.shape[0]?.length||1)/2)))
        if(willClear.length>0){
          const row = willClear[willClear.length-1]
          const filledByPiece: number[] = []
          for(let c=0;c<COLS;c++){
            if(!before[row][c] && ng[row][c]) filledByPiece.push(c)
          }
          if(filledByPiece.length>0) hole = filledByPiece[Math.floor(filledByPiece.length/2)]
        }
        if(info.total) receiveGarbage(1, info.total, hole)

        if(res.cleared>0) combo2.current = combo2.current + 1
        else combo2.current = 0
        b2b2.current = info.qualifies ? true : false

        if(res.grid[0].some((cell:any)=>!!cell)){
          setRunning2(false); setGameOver(true); setWinner('player')
        }
        if(grid1[0].some((cell:any)=>!!cell)){
          setRunning1(false); setRunning2(false); setGameOver(true); setWinner('opponent')
        }

        if(!gameOver){
          if(reason==='soft') setTimeout(()=>{ if(!gameOver) spawn(2) }, 500)
          else spawn(2)
        }

        return res.grid
      })
    }
  }

  function spawn(player:number){
    if(gameOver) return
    if(player===1){
      setQueue1(q=>{
        const [, ...rest] = q
        const next = {...randomTetromino(), x:3, y:-2}
        const chosen = {...rest[0] || next}
        queue1Ref.current = [...rest, next]
        setPiece1AndRef(chosen)
        // if the soft-drop key is currently held, resume soft-drop immediately for the new piece
        if(pressedKeys.current['s'] || pressedKeys.current['arrowdown']) setSoftDrop1(true)
        setHoldUsed1(false)
        return queue1Ref.current
      })
    } else {
      setQueue2(q=>{
        const [, ...rest] = q
        const next = {...randomTetromino(), x:3, y:-2}
        const chosen = {...rest[0] || next}
        setPiece2(chosen)
        setHoldUsed2(false)
        if(pressedKeys.current['s'] || pressedKeys.current['arrowdown']){
          // if opponent soft-drop held we would set their soft-drop state here (not implemented for opponent in this UI)
        }
        return [...rest, next]
      })
    }
  }

  // safe hold operation for player 1 to avoid nested state updates
  function performHold1(){
    if(holdUsed1) return
    setHoldUsed1(true)
    // stop soft-drop while swapping to avoid interval acting on the old piece
    setSoftDrop1(false)
    const current = piece1Ref.current
    // use functional updaters to avoid stale closures
    if(!held1Ref.current){
      // move current piece into hold and spawn next from queue
      setHeld1(prev=>{ const h = {...current, x:0, y:0}; held1Ref.current = h; return h })
      setQueue1(q=>{
        const [, ...rest] = q
        const nextFromQueue = rest[0] || randomTetromino()
        const nextPiece = {...nextFromQueue, x:3, y:-2}
        // advance the queue and refill at end
        const newQueue = [...rest, randomTetromino()].map(p=> ({...p, x:3, y:-2}))
        queue1Ref.current = newQueue
        setPiece1AndRef(nextPiece)
        // if soft-drop key is held, resume soft-drop for the new piece
        if(pressedKeys.current['s'] || pressedKeys.current['arrowdown']) setSoftDrop1(true)
        return newQueue
      })
    } else {
      // swap held into play, put current into hold
      const heldNow = held1Ref.current as Piece
      setHeld1(prev=>{ const h = {...current, x:0, y:0}; held1Ref.current = h; return h })
      const nextPiece = {...heldNow, x:3, y:-2}
      setPiece1AndRef(nextPiece)
      if(pressedKeys.current['s'] || pressedKeys.current['arrowdown']) setSoftDrop1(true)
    }
  }

  // receiveGarbage now supports delayed application (frames) and aligned holes every 2 rows
  function receiveGarbage(player:number, lines:number, holeCol?:number){
    // frame delay: 20 frames (approx 333ms at 60fps)
    const frameDelay = Math.round((1000/60) * 20)
    const apply = ()=>{
      const makeRow = (hole:number)=> Array.from({length:COLS}, (_,i)=> i===hole?0:'G:#888888')
      if(player===1){
        setGrid1(g=>{
          const ng = g.map(r=>r.slice())
          // build rows with aligned holes per 2-row groups
          for(let i=0;i<lines;i+=2){
            const hole = (typeof holeCol === 'number') ? holeCol : Math.floor(Math.random()*COLS)
            // first of the pair
            ng.shift(); ng.push(makeRow(hole))
            // second of the pair if exists
            if(i+1<lines){ ng.shift(); ng.push(makeRow(hole)) }
          }
          // check top row
          if(ng[0].some((cell:any)=>!!cell)){
            setRunning1(false); setGameOver(true); setWinner('opponent')
          }
          return ng
        })
      } else {
        setGrid2(g=>{
          const ng = g.map(r=>r.slice())
          for(let i=0;i<lines;i+=2){
            const hole = (typeof holeCol === 'number') ? holeCol : Math.floor(Math.random()*COLS)
            ng.shift(); ng.push(makeRow(hole))
            if(i+1<lines){ ng.shift(); ng.push(makeRow(hole)) }
          }
          if(ng[0].some((cell:any)=>!!cell)){
            setRunning1(false); setRunning2(false); setGameOver(true); setWinner('player')
          }
          return ng
        })
      }
    }
    setTimeout(apply, frameDelay)
  }

  // gravity for player; slow speed-up over time. Soft-drop handled separately at a constant rate.
  useEffect(()=>{
    if(!running1) return
    const base = 800
    let mounted = true
    let timer: number | undefined
    const tick = ()=>{
      const elapsed = (Date.now() - startTime.current)/1000
      // very small speedup over time: -5ms every 10s
      const speed = Math.max(200, base - Math.floor(elapsed/10)*2)
      // compute gravity step from the latest piece ref so any horizontal input applied earlier in the same tick is respected
      const current = piece1Ref.current
      const moved = {...current, y: current.y+1}
  if(collide(grid1Ref.current, moved)){
        // landing: use the latest piece (current) when locking
        lockAndClear(1, current, 'gravity')
      } else {
        // apply the moved piece atomically to ref and state
        setPiece1AndRef(moved)
      }
      if(mounted) timer = window.setTimeout(tick, speed) as unknown as number
    }
    timer = window.setTimeout(tick, 0) as unknown as number
    return ()=>{ mounted = false; if(timer) clearTimeout(timer) }
  },[grid1, running1, queue1])

  useEffect(()=>{
    if(!running2) return
    const base = 800
    let mounted = true
    let timer: number | undefined
    const tick = ()=>{
      const elapsed = (Date.now() - startTime.current)/1000
      const speed = Math.max(200, base - Math.floor(elapsed/10)*2)
      const current = piece2Ref.current
      const moved = {...current, y: current.y+1}
  if(collide(grid2Ref.current, moved)){
        lockAndClear(2, current, 'gravity')
      } else {
        setPiece2AndRef(moved)
      }
      if(mounted) timer = window.setTimeout(tick, speed) as unknown as number
    }
    timer = window.setTimeout(tick, 0) as unknown as number
    return ()=>{ mounted = false; if(timer) clearTimeout(timer) }
  },[grid2, running2, queue2])

  // soft-drop: constant-rate separate interval started on keydown and stopped on keyup
  useEffect(()=>{
    if(!running1) return
    let id: number | undefined
    if(softDrop1){
      id = window.setInterval(()=>{
        const current = piece1Ref.current
        const moved = {...current, y: current.y+1}
        if(collide(grid1Ref.current, moved)){
          // lock if landing (soft drop -> delayed spawn)
          lockAndClear(1, current, 'soft')
          setSoftDrop1(false)
          return
        }
        setPiece1AndRef(moved)
      }, 50) as unknown as number
    }
    return ()=>{ if(id) clearInterval(id) }
  },[softDrop1, running1, queue1])

  // controls (WASD and Arrow keys both supported). Prevent default for space/arrow to stop page scroll.
  useEffect(()=>{
    function onKey(e:KeyboardEvent){
      if(!running1) return
      const raw = e.key
      const k = typeof raw === 'string' ? raw.toLowerCase() : raw
      // prevent default for space and arrow keys
      if(k === ' ' || k.startsWith('arrow')) e.preventDefault()
  // ignore repeated OS keydown events; we manage repeats with our own intervals
  if(pressedKeys.current[k]) return
  pressedKeys.current[k] = true

  if(k==='a' || k==='arrowleft'){
        // start immediate left move and begin repeat interval
        if(horizontalDir.current !== 'left'){
          horizontalDir.current = 'left'
          // use ref to avoid races with gravity
          const base = piece1Ref.current
          const moved = {...base, x: base.x-1}
          if(!collide(grid1Ref.current,moved)) setPiece1AndRef(moved)
          if(horizontalInterval.current) clearInterval(horizontalInterval.current)
          horizontalInterval.current = window.setInterval(()=>{
            const base2 = piece1Ref.current
            const moved2 = {...base2, x: base2.x-1}
            if(!collide(grid1Ref.current,moved2)) setPiece1AndRef(moved2)
          }, 80) as unknown as number
        }
      } else if(k==='d' || k==='arrowright'){
        if(horizontalDir.current !== 'right'){
          horizontalDir.current = 'right'
          const base = piece1Ref.current
          const moved = {...base, x: base.x+1}
          if(!collide(grid1Ref.current,moved)) setPiece1AndRef(moved)
          if(horizontalInterval.current) clearInterval(horizontalInterval.current)
          horizontalInterval.current = window.setInterval(()=>{
            const base2 = piece1Ref.current
            const moved2 = {...base2, x: base2.x+1}
            if(!collide(grid1Ref.current,moved2)) setPiece1AndRef(moved2)
          }, 80) as unknown as number
        }
      } else if(k==='s' || k==='arrowdown'){
        // start soft drop (no immediate step; interval provides constant speed)
        if(!softDrop1) setSoftDrop1(true)
      } else if(k==='w' || k==='arrowup'){
  setPiece1(prev=> tryRotate(grid1Ref.current, prev))
      } else if(k===' '){
        // hard drop: compute landing and use lockAndClear so garbage & scoring follow same path
        setSoftDrop1(false)
  const p = piece1Ref.current
  let landing = {...p}
  while(!collide(grid1Ref.current, {...landing, y: landing.y+1})) landing.y++
  lockAndClear(1, landing, 'hard')
      } else if(k==='c'){
        // use atomic hold to avoid nested setState and race conditions
        performHold1()
      }
    }

    function onKeyUp(e:KeyboardEvent){
      const k = (typeof e.key === 'string') ? e.key.toLowerCase() : e.key
      if(k==='s' || k==='arrowdown') setSoftDrop1(false)
      if(k==='a' || k==='arrowleft' || k==='d' || k==='arrowright'){
        // stop horizontal repeat
        if(horizontalInterval.current) { clearInterval(horizontalInterval.current); horizontalInterval.current = undefined }
        horizontalDir.current = null
      }
      // clear pressedKeys marker so subsequent physical presses are handled
      if(pressedKeys.current[k]) pressedKeys.current[k] = false
    }

    window.addEventListener('keydown', onKey, { passive: false })
    window.addEventListener('keyup', onKeyUp)
    return ()=>{ window.removeEventListener('keydown', onKey); window.removeEventListener('keyup', onKeyUp) }
  },[grid1, running1, held1, holdUsed1, queue1, piece1])

  // previews
  function PiecePreview({p, size=64}:{p:Piece|null, size?:number}){
    const cell = Math.floor(size/4)
    const cols = 'repeat(4, ' + cell + 'px)'
    const items = Array.from({length:16}).map((_,i)=>{
      const r = Math.floor(i/4); const c = i%4
      const show = p && p.shape[r] && p.shape[r][c]
      const color = p ? (COLORS as any)[p.key] : undefined
      return (<div key={i} style={{width:cell, height:cell, background: show? color : 'transparent'}}></div>)
    })
    return (<div style={{width:size, height:size, display:'grid', gridTemplateColumns: cols, gap:2}}>{items}</div>)
  }

  return (
    <div style={{display:'flex', justifyContent:'center'}}>
      <div style={{marginBottom:8}}>
        <button onClick={()=>{
          startTime.current = Date.now()
          setGrid1(makeEmptyGrid()); setGrid2(makeEmptyGrid());
          setQueue1(createQueue()); setQueue2(createQueue());
          setPiece1(createStart()); setPiece2(createStart());
          setHeld1(null); setHeld2(null); setHoldUsed1(false); setHoldUsed2(false);
          setScore1(0); setScore2(0); setRunning1(true); setRunning2(true); setGameOver(false); setWinner(null)
        }}>Restart</button>
      </div>

      <div style={{display:'flex', gap:24, alignItems:'flex-start'}}>
        {/* Player area: left side has hold/next stacked, then canvas */}
        <div style={{display:'flex', gap:12, alignItems:'flex-start'}}>
          <div style={{display:'flex', flexDirection:'column', gap:8, alignItems:'center'}}>
            <div style={{fontSize:12, color:'#ccc'}}>Hold</div>
            <PiecePreview p={held1} />
            <div style={{height:8}} />
            <div style={{fontSize:12,color:'#ccc'}}>Next</div>
            <div style={{display:'flex', flexDirection:'column', gap:6}}>
              {queue1.slice(1,6).map((q,i)=> <PiecePreview key={i} p={q} size={36} />)}
            </div>
          </div>

          <div>
            <h4>Player</h4>
            <canvas ref={canvas1} style={{border:'1px solid #122'}} />
            <div style={{marginTop:8}}>Score: {score1}</div>
          </div>
        </div>

        {/* center divider */}
        <div style={{width:2, background:'#122', margin:'6px 4px'}} aria-hidden/>

        {/* Opponent area: canvas then hold/next to the right for symmetry */}
        <div style={{display:'flex', gap:12, alignItems:'flex-start'}}>
          <div>
            <h4>Opponent</h4>
            <canvas ref={canvas2} style={{border:'1px solid #122'}} />
            <div style={{marginTop:8}}>Score: {score2}</div>
          </div>

          <div style={{display:'flex', flexDirection:'column', gap:8, alignItems:'center'}}>
            <div style={{fontSize:12,color:'#ccc'}}>Hold</div>
            <PiecePreview p={held2} />
            <div style={{height:8}} />
            <div style={{fontSize:12,color:'#ccc'}}>Next</div>
            <div style={{display:'flex', flexDirection:'column', gap:6}}>
              {queue2.slice(1,6).map((q,i)=> <PiecePreview key={i} p={q} size={36} />)}
            </div>
          </div>
        </div>
      </div>

      {gameOver && winner && (
        <div style={{position:'fixed', left:0, top:0, right:0, bottom:0, display:'flex', alignItems:'center', justifyContent:'center', background:'rgba(0,0,0,0.6)'}}>
          <div style={{color:'#fff', textAlign:'center'}}>
            <h2>{winner==='player'? 'You Win!' : winner==='opponent'? 'You Lose' : 'Draw'}</h2>
            <button onClick={()=>{
              startTime.current = Date.now()
              setGrid1(makeEmptyGrid()); setGrid2(makeEmptyGrid());
              setQueue1(createQueue()); setQueue2(createQueue());
              setPiece1(createStart()); setPiece2(createStart());
              setHeld1(null); setHeld2(null); setHoldUsed1(false); setHoldUsed2(false);
              setScore1(0); setScore2(0); setRunning1(true); setRunning2(true); setGameOver(false); setWinner(null)
            }}>Restart</button>
          </div>
        </div>
      )}
    </div>
  )
}

